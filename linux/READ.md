# Linux kernel

## 进程相关信息

Linux在启动一个进程时,系统会在/proc下创建一个以PID命名的文件夹,在该文件夹下会保存进程的信息,通过ls -l命令即可查看。
ls -l /proc/PID
目录下文件功能:
cwd  符号链接的是进程运行目录
exe  符号连接就是执行程序的绝对路径
cmdline 就是程序运行时输入的命令行命令
environ 记录了进程运行时的环境变量
fd  目录下是进程打开或使用的文件的符号连接
maps  进程的虚拟地址空间

Linux将进程虚拟地址空间中的一个段叫做虚拟内存区域(VMA)。在/proc目录下,可以查看一个进程的虚拟地址空间,通过命令 cat /proc/pid/maps

## 创建新的进程

fork、vfork和clone三个用户态函数均由libc库提供,它们分别会调用Linux内核提供的同名系统调用fork,vfork和clone。下面以fork系统调用为例来介绍。传统的创建一个新进程的方式是子进程拷贝父进程所有资源,这无疑使得进程的创建效率低,因为子进程需要拷贝父进程的整个地址空间。更糟糕的是,如果子进程创建后又立马去执行exec族函数,那么刚刚才从父进程那里拷贝的地址空间又要被清除以便装入新的进程映像。为了解决这个问题,内核中提供了上述三种不同的系统调用。

1. 内核采用写时复制技术对传统的fork函数进行了下面的优化。即子进程创建后,父子以只读的方式共享父进程的资源(并不包括父进程的页表项)。当子进程需要修改进程地址空间的某一页时,才为子进程复制该页。采用这样的技术可以避免对父进程中某些数据不必要的复制。
2. 使用vfork函数创建的子进程会完全共享父进程的地址空间,甚至是父进程的页表项。父子进程任意一方对任何数据的修改使得另一方都可以感知到。为了使得双方不受这种影响,vfork函数创建了子进程后,父进程便被阻塞直至子进程调用了exec()或exit()。由于现在fork函数引入了写时复制技术,在不考虑复制父进程页表项的情况下,vfork函数几乎不会被使用。
3. clone函数创建子进程时灵活度比较大,因为它可以通过传递不同的clone标志参数来选择性的复制父进程的资源。

## x86 获取保存寄存器信息的结构体

在i386结构下包含的头文件是<linux/user.h>
在x64机器上需要进行修改,改成<sys/user.h>
其实最终访问的文件是/usr/include/x86_64-linux-gnu/sys/user.h

eip寄存器存储着我们cpu要读取指令的地址,没有了它,cpu就无法读取下面的指令
RIP --- x64体系
EIP --- x86体系

struct user_regs_struct regs;

## 检测是否处于被调试状态

通过GET_THREAD_INFO宏获得当前进程的thread_info结构的地址
再检测当前进程是否被其他进程所跟踪(例如调试一个程序时,被调试的程序就处于被跟踪状态),也就是thread_info结构中flag字段的_TIF_ALLWORK_MASK被置1。
如果发生被跟踪的情况则转向syscall_trace_entry标记的处理命令处。
